/**
 * Report command - Generate daily summary
 */

import chalk from "chalk";
import ora from "ora";
import { readFile, writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import type { ToolScore, DailyReport } from "../models/types";

const DATA_DIR = join(import.meta.dir, "../../data");

interface ReportOptions {
  date: string;
}

export async function reportCommand(options: ReportOptions): Promise<void> {
  const spinner = ora("Generating daily report...").start();

  try {
    const { date } = options;
    const scoresPath = join(DATA_DIR, "scores", `${date}.json`);
    const reportsDir = join(DATA_DIR, "reports");

    if (!existsSync(scoresPath)) {
      spinner.fail(`No scores found for ${date}`);
      console.log(chalk.yellow(`  Run 'bun run score' first`));
      return;
    }

    const scores: ToolScore[] = JSON.parse(await readFile(scoresPath, "utf-8"));

    // Generate report
    const report: DailyReport = {
      date,
      toolsEvaluated: scores.length,
      recommendations: {
        build: scores
          .filter((s) => s.recommendation === "BUILD")
          .map((s) => s.tool.name),
        watch: scores
          .filter((s) => s.recommendation === "WATCH")
          .map((s) => s.tool.name),
        skip: scores
          .filter((s) => s.recommendation === "SKIP")
          .map((s) => s.tool.name),
      },
      topTools: scores.slice(0, 5),
      builtToday: [], // Would be populated by build command
      generatedAt: new Date().toISOString(),
    };

    // Generate markdown report
    const markdown = generateReportMarkdown(report, scores);

    // Save report
    await mkdir(reportsDir, { recursive: true });
    const reportPath = join(reportsDir, `${date}-report.md`);
    await writeFile(reportPath, markdown);

    // Also save JSON
    const jsonPath = join(reportsDir, `${date}-report.json`);
    await writeFile(jsonPath, JSON.stringify(report, null, 2));

    spinner.succeed(`Report generated for ${date}`);

    // Print report to console
    console.log(chalk.cyan("\n" + "â•".repeat(60)));
    console.log(markdown);
    console.log(chalk.cyan("â•".repeat(60) + "\n"));

    console.log(chalk.gray(`  Saved to: ${reportPath}`));
  } catch (error) {
    spinner.fail("Failed to generate report");
    console.error(
      chalk.red(error instanceof Error ? error.message : String(error)),
    );
  }
}

function generateReportMarkdown(
  report: DailyReport,
  scores: ToolScore[],
): string {
  let md = `# Daily Tool Update Report - ${report.date}\n\n`;

  md += `## Summary\n\n`;
  md += `- **Tools Evaluated:** ${report.toolsEvaluated}\n`;
  md += `- **BUILD:** ${report.recommendations.build.length}\n`;
  md += `- **WATCH:** ${report.recommendations.watch.length}\n`;
  md += `- **SKIP:** ${report.recommendations.skip.length}\n`;
  md += `- **Generated:** ${new Date(report.generatedAt).toLocaleString()}\n\n`;

  if (report.recommendations.build.length > 0) {
    md += `## ðŸš€ Recommended to BUILD\n\n`;
    report.recommendations.build.forEach((name) => {
      const score = scores.find((s) => s.tool.name === name);
      if (score) {
        md += `### ${name} (${score.totalScore}/100)\n\n`;
        md += `> ${score.tool.description}\n\n`;
        md += `**Scores:**\n`;
        md += `- Usefulness: ${score.usefulnessScore}/100\n`;
        md += `- Quality: ${score.qualityScore}/100\n`;
        md += `- Innovation: ${score.innovationScore}/100\n`;
        md += `- Momentum: ${score.momentumScore}/100\n\n`;
        if (score.tool.installCommand) {
          md += `**Install:** \`${score.tool.installCommand}\`\n\n`;
        }
        if (score.notes.length > 0) {
          md += `**Notes:**\n`;
          score.notes.forEach((note) => {
            md += `- ${note}\n`;
          });
          md += "\n";
        }
      }
    });
  }

  if (report.recommendations.watch.length > 0) {
    md += `## ðŸ‘€ Watch List\n\n`;
    report.recommendations.watch.forEach((name) => {
      const score = scores.find((s) => s.tool.name === name);
      if (score) {
        md += `- **${name}** (${score.totalScore}/100) - ${score.tool.description.slice(0, 100)}...\n`;
      }
    });
    md += "\n";
  }

  if (report.recommendations.skip.length > 0) {
    md += `## â­ï¸ Skipped\n\n`;
    report.recommendations.skip.forEach((name) => {
      const score = scores.find((s) => s.tool.name === name);
      if (score) {
        md += `- ${name} (${score.totalScore}/100)\n`;
      }
    });
    md += "\n";
  }

  md += `---\n\n`;
  md += `*Generated by Daily Tool Updates CLI*\n`;

  return md;
}

export { generateReportMarkdown };
